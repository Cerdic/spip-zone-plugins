[(#REM)

	Modèle pour produire des graphiques avec Chart.js

	Usage recommandé (les 2 exemples produisent le même résultat) :
	- Dans le texte d'un contenu :
	<chart|id=toto|type=line|data="10,20,30 next 5,10,15"|labels="2005,2006,2007"|dataLabels="patates,poireaux">
	- Dans un squelette :
	#MODELE{chart, id=toto, type=line, data=#ARRAY{patates,#ARRAY{10,20,30},poireaux,#ARRAY{5,10,15}}}

	Paramètres :
	**obligatoires
	*recommandés

	<!-- Conteneur -->
	- *id :           Identifiant du graphe
	- *class :        Classes supplémentaires du conteneur
	- width :         Largeur du conteneur, avec l'unité
	- height :        Hauteur du conteneur, avec l'unité

	<!-- Données et textes -->
	- **type :        Type de graphique (string)
	                  pie (défaut) | line | bar | radar | doughnut | polarArea | bubble | scatter | area | mixed
	- **data :        Jeux de données (string|array)
	                  - a) soit des séries de nombres séparés par des virgules et le séparateur 'next'
                      Ex. : "10,20,30 next 5,10,15"
	                  - b) soit un tableau linéaire
	                    Ex. #LISTE{10,20,30}
	                  - c) soit un tableau simple avec labels et données (recommandé)
	                    Ex. : #ARRAY{
	                            patates, #ARRAY{10,20,30},
	                            poireaux, #ARRAY{5,10,15}
	                          }
	                  - d) soit un tableau complet avec *toutes* les options, si on sait ce qu'on fait.
	                    Dans ce cas là, c'est vous qui décidez de tout : les couleurs etc.
	                    Ex. : #LISTE{
	                            #ARRAY{label,patates, data,#LISTE{10,20,30}, borderColor,red},
	                            #ARRAY{label,poireaux, data,#LISTE{5,10,15}, borderColor,blue}
	                          }
	- *labels :       Labels utilisés en abscisse (string|array)
	                  - soit des mots séparés par des virgules : "2005,2006,2007"
	                  - soit un tableau : #LISTE{carotte,chou,tomate}
	- dataLabels :   Labels de chaque jeu de données (string|array)
	                  Inutile si vous passez un tableau c) ou d) au paramètre 'data'
	                  - soit des mots séparés par des virgules : "patates,poireaux"
	                  - soit un tableau : #LISTE{patates,poireaux}

	<!-- Apparence -->
	- colors :        Codes de couleurs à utiliser : nom, hexadécimal, rgb, rgba, hsl, hsla
	                  - soit des valeurs séparées par des virgules : "turquoise,blue"
	                  - soit un tableau : #LISTE{turquoise,blue}
	- borderWidth :   Épaisseur des bordures, sans l'unité (int)
	                  Défaut = 1
	- fill :          Remplir ou pas les graphes (string|bool)
	                  true | false (dépend des types)

	<!-- Options générales -->
	- options :      Tableaux complet d'options, si on sait ce qu'on fait (array)
	                 Prend le pas sur les autres options données individuellement
	                 Exemple : #ARRAY{responsive,false}
	- stacked :      Pour avoir des données empilées (string)
                   true | false (défaut)
	- responsive :   Mode responsive
                   true (défaut) | false

	<!-- Dépréciés -->
	- datasets :      Utiliser 'data'
	- animation :     ?
	- datasetFill :   Utiliser 'fill'
	- canvaswidth :   Utiliser 'width'
	- canvasheight :  Utiliser 'height'
	- strokeColor :   Utiliser 'borderColor'
	- pointColor :    Utiliser 'backgroundColor'
	- pointstrokecolor : Utiliser 'borderColor'
	- pointHighlightFill : Utiliser 'backgroundColor'
	- pointHighlightStroke : Utiliser 'borderColor'

]
[(#REM)
	============================
	1) Normaliser les paramètres
	============================
]
[(#REM) Base ]
#SET{type,         #ENV{type,pie}|trim|strtolower}
#SET{alias,        #ARRAY{polararea,polarArea}}
#SET{type,         #GET{alias/GET{type}}|sinon{#GET{type}}}
#SET{id,           #ENV{id,chart}|replace{' '}}
#SET{donnees,      #ENV{data,datasets}}
[(#REM) Apparence ]
#SET{width,        #ENV{width,#ENV{canvaswidth}}}
#SET{height,       #ENV{height,#ENV{canvasheight}}}
#SET{colors,       #ENV{colors}|is_null|?{
	#LISTE{#69D2E7,#E0E4CC,#F38630,#96CE7F,#CEBC17,#CE4264,#F7464A,#46BFBD,#FDB45C},
	#ENV{colors}|is_string|?{#ENV{colors}|replace{' '}|explode{','}, #ENV{colors}}
}}
#SET{fills,        #ARRAY{line,false,bar,true,pie,true}}
#SET{fill,         #ENV{fill,#GET{fills/#GET{type}}}}
[(#REM) Options ]
#SET{stacked,      #ENV{stacked}|=={true}|?{true}}
#SET{responsive,   #ENV{responsive}|=={false}|?{false}}


[(#REM)
	==================================
	2) Préparer les données pour le JS
	==================================
	On construit des tableaux qu'ils nous suffira d'encoder en JS dans le script.
]

[(#REM)
	Jeux de données
	Au final on veut obtenir un tableau de la forme suivante :
	array (
		array (
			'label'   => 'patates',
			'data'    => array(10,30,20),
			'option1' => 'x',
			'option2' => 'y',
		),
		array (
			'label'   => 'poireaux',
			'data'    => array(20,40,10),
			'option1' => 'x',
			'option2' => 'y',
		)
	)
]
[(#REM) On convertit le texte en tableau si nécessaire ]
[(#GET{donnees}|is_string|oui)
#SET{donnees, #VAL{chartjs_explode_virgule}|array_map{#GET{donnees}|explode{next}}}
]
[(#REM) Si on a un tableau linéaire, on le réarrange ]
[(#GET{donnees/0}|is_string|oui)
#SET{donnees,#LISTE{#GET{donnees}}}
]
[(#REM) Maintenant on a 2 options :
	- si on a un tableau complet on le prend tel quel
	- sinon on construit le tableau complet nous-même
]
#SET{datasets, #ARRAY}
#SET{tableau_est_complet, #GET{donnees/0/data}|?{oui}}
<BOUCLE_datasets(DATA){source table, #GET{donnees}}{si #GET{tableau_est_complet}|non}>
#SET{compteur, #COMPTEUR_BOUCLE|moins{1}}
#SET{borderColor, #GET{colors/#GET{compteur}}}
#SET{backgroundColor, #GET{colors/#GET{compteur}}}
#SET{dataset, #ARRAY{
	label,           #CLE,
	data,            #VALEUR,
	borderColor,     #GET{borderColor},
	backgroundColor, #GET{backgroundColor},
	fill,            #GET{fill}
}}
#SET{datasets, #GET{datasets}|push{#GET{dataset}}}
</BOUCLE_datasets>
#SET{datasets, #GET{donnees}}
<//B_datasets>

[(#REM) Labels en abscisse ]
#SET{labels, #ENV{labels}|is_string|?{#ENV{labels}|replace{' '}|explode{','}, #ENV{labels}}}

[(#REM) Options générales :
	- si on a un tableau complet, on le prend tel quel
	- sinon, on les prend individuellement
]
<BOUCLE_options(CONDITION){si #ENV{options}|is_array}>
#SET{options, #ENV{options}}
</BOUCLE_options>
#SET{scales, #ARRAY{
	xAxes,#LISTE{#ARRAY{stacked,#GET{stacked}|?{true}}},
	yAxes,#LISTE{#ARRAY{stacked,#GET{stacked}|?{true}}}
}}
#SET{options,#ARRAY{
	responsive, #GET{responsive},
	scales,     #GET{scales}
}}
#SET{options, #GET{options}|chartjs_array_filter_recursive}
<//B_options>


[(#REM)
	========================
	3) Affichage du graphique
	========================
]


<div
	class="spip-chart-wrap[ spip-chart-align-(#GET{align})][ (#GET{class})]" 
	style="position:relative; max-width:100%;[ width:(#GET{width})];[ height:(#GET{height})];"
>
	<canvas id="#GET{id}" class="spip-chart-canvas"></canvas>
</div>

<script>
$(document).ready(function(){
	var conteneur[_(#GET{id})] = $("[#(#GET{id})]");
	var spipChart[_(#GET{id})] = new Chart(conteneur[_(#GET{id})], {
		type: ['(#GET{type})'], // Type de graphe
		data: {
			labels:   [(#GET{labels}|json_encode)], // Labels en abscisse
			datasets: [(#GET{datasets}|chartjs_array_typecaster|json_encode)], // Jeux de données et leurs options
		},
		options: [(#GET{options}|chartjs_array_typecaster|json_encode)] // Options générales
	});
});
</script>
