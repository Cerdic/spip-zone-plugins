[(#REM)

Modele carte_gis
----------------

Parametres possibles :

- id_map|id_carte_gis = 1          id de la carte
- lat|latit|latitude = 48.3        latitude du centre de la carte
- lon|lonxit|longitude = -4.7      longitude du centre de la carte
- zoom = 5                         zoom de la carte
- maxZoom = 13                     zoom maximum autorisé

- sw_lat = lat - 10°               latitude du sud-ouest de la bounding box
- sw_lon = lon - 10°               longitude du sud-ouest de la bounding box
- ne_lat = lat + 10°               latitude du nord-est de la bounding box
- ne_lon = lon + 10°               longitude du nord-est de la bounding box

- width|largeur = 100%             largeur de la carte, 100% par defaut
- height|hauteur = 400px           hauteur de la carte, 400px par defaut
- style = non                      ne pas styler la carte

- fullscreen = oui                     afficher un bouton pour passer la carte en plein écran
- zoom_molette|zoom_wheel = non        désactiver le zoom avec la molette de la souris, actif par defaut
- control_type|controle_type = non     ne pas afficher les controles de changement de type
- no_control|aucun_controle = oui      ne pas afficher les controles de la carte
- scale = oui                          afficher l'échelle de la carte
- overview = oui                       afficher une mini carte de situation

- autocenterandzoom|centrer_auto = oui        centrer et zoomer la carte automatiquement pour afficher tous les marqueurs
- localize_visitor|localiser_visiteur = oui   centrer la carte sur la position du visiteur (API geolocation HTML5)

- objets = gis                     type d'objets à afficher (fichier json/gis_xx qui génère la source de donnees)
- limit|limite = 500               nombre max de marqueurs à afficher, 500 par defaut
- kml = 12                         kml à superposer à la carte (id_document ou url ou liste d'url)
- gpx = 12                         gpx à superposer à la carte (id_document ou url ou liste d'url)
- centrer_fichier = non            permet de ne pas centrer la carte automatiquement sur les fichiers kml/gpx surperposés
- point = non                      si elle vaut "non" cette option n'affichera pas de points du tout (utile pour n'afficher qu'un kml par exemple)

- media = non                      permet de passer le critère 'media' (pour les documents)
- path_styles=#ARRAY{color,#fff}   options de style des éléments de la couche GeoJSON (voir http://leafletjs.com/reference.html#path-options)

Uniquement si objets = point_libre :
- icone = chemin/vers/image        image utilisée pour le marker
- titre                            titre du point
- description                      description du point

Clustering (regroupement de points proches) :
- cluster = oui                    Active le clustering
- clusterMaxZoom = 11              Regroupe les points jusque à ce zoom, mais pas au delà
- clusterStyles = #ARRAY{}         Styles appliqués aux clusters

]

[(#SET{width,#ENV{width,#ENV{largeur,100%}}})]
[(#SET{height,#ENV{height,#ENV{hauteur,400px}}})]
[(#SET{id,#ENV{id_carte_gis,#ENV{id_map,#ENV{id,1}}}})]
[(#REM) -- compat gis v1 -- ]
[(#SET{lat,#ENV{lat,#ENV{latit,#ENV{latitude,#CONFIG{gis/lat,0}}}}})]
[(#SET{lon,#ENV{lon,#ENV{lonxit,#ENV{longitude,#CONFIG{gis/lon,0}}}}})]
[(#REM) On utilise la bounding box seulement si le centre n'a pas été donné et si les quatre valeurs de la bounding box sont renseignées
    les valeurs par defaut sont "centre +/- 10°", ce qui est naze, mais c'est un cas normalement impossible
]
[(#ENV{lat}|ou{#ENV{lon}}|non|et{#ENV{sw_lat}}|et{#ENV{sw_lon}}|et{#ENV{ne_lat}}|et{#ENV{ne_lon}})
	#SET{utiliser_bb, oui}
	#SET{sw_lat,#ENV{sw_lat,#GET{lat}|moins{10}}}
	#SET{sw_lon,#ENV{sw_lon,#GET{lon}|moins{10}}}
	#SET{ne_lat,#ENV{ne_lat,#GET{lat}|plus{10}}}
	#SET{ne_lon,#ENV{ne_lon,#GET{lon}|plus{10}}}
]

<div id="map[(#GET{id})]" class="carte_gis p"[(#ENV{style}|!={'non'}|?{' '})style="[width:(#GET{width});][ height:(#GET{height});]"]></div>

<script type="text/javascript">/*<!\[CDATA\[*/

var map[(#GET{id})];

(function($){

	var init_map[(#GET{id})] = function(callback) {
		var map_container = 'map[(#GET{id})]';

		// Création de la carte Leafleat
		map[(#GET{id})] = new L.Map(map_container,{
			scrollWheelZoom: [(#ENV{zoom_molette,#ENV{zoom_wheel}}|=={non}|?{false,true})],
			zoomControl: [(#ENV{no_control,#ENV{aucun_controle}}|!={oui}|?{true,false})][,
			maxZoom: (#ENV{maxZoom})]
		});

		// Appeler l'éventuelle fonction de callback
		if (callback && typeof(callback) === "function") {
			map[(#GET{id})].on('load',function(e){
				callback(e.target);
			});
		}

		// Déterminer la position initiale de la carte
		[(#GET{utiliser_bb}|non)
		map[(#GET{id})].setView(new L.LatLng([(#GET{lat})], [(#GET{lon})]), [(#ENV{zoom,#CONFIG{gis/zoom,0}})]);]

		[(#GET{utiliser_bb}|oui)
		map[(#GET{id})].fitBounds(
			new L.LatLngBounds(
				new L.LatLng([(#GET{sw_lat})], [(#GET{sw_lon})]),
				new L.LatLng([(#GET{ne_lat})], [(#GET{ne_lon})])
			)
		);]

		// Fond de carte par défaut (layer)
		#SET{layer_defaut,#REM|gis_layer_defaut} #SET{layers,#EVAL{$GLOBALS['gis_layers']}}
		var [(#GET{layer_defaut})] = [new (#GET{layers/#GET{layer_defaut}/layer})];
		map[(#GET{id})].addLayer([(#GET{layer_defaut})]);

		<B_layers>
		// liste des fonds de carte possibles
		var layers_control = new L.Control.Layers();
		layers_control.addBaseLayer([(#GET{layer_defaut})],["(#GET{layers/#GET{layer_defaut}/nom})"]);
		<BOUCLE_layers(DATA){source table, #GET{layers}}
			{si #ENV{control_type,#ENV{controle_type}}|!={non}}
			{si #ENV{no_control,#ENV{aucun_controle}}|!={oui}}
			{si #CONFIG{gis/layers,#ARRAY}|count|>{1}}>[
		(#CLE|!={#GET{layer_defaut}}|et{#CLE|in_any{#CONFIG{gis/layers}}|oui})
		layers_control.addBaseLayer([new (#LAYER)],"#NOM");]
		</BOUCLE_layers>
		map[(#GET{id})].addControl(layers_control);
		// ajouter l'objet du controle de layers à la carte pour permettre d'y accéder depuis le callback
		map[(#GET{id})].layersControl = layers_control;
		// classe noajax sur le layer_control pour éviter l'ajout de hidden par SPIP
		$(layers_control._form).addClass('noajax');
		</B_layers>

		map[(#GET{id})].setView(new L.LatLng(#GET{lat},#GET{lon}),#ENV{zoom,#CONFIG{gis/zoom,0}});

		map[(#GET{id})].attributionControl.setPrefix('');

		// Ajout des contrôles de la carte
		[(#ENV{scale}|et{#ENV{no_control,#ENV{aucun_controle}}|!={oui}}|oui)
		map[(#GET{id})].addControl(new L.Control.Scale());
		][(#ENV{fullscreen}|et{#ENV{no_control,#ENV{aucun_controle}}|!={oui}}|oui)
		map[(#GET{id})].addControl(new L.Control.FullScreen());
		][(#ENV{overview}|et{#ENV{no_control,#ENV{aucun_controle}}|!={oui}}|oui)
		var minimap_layer = [new (#GET{layers/#GET{layer_defaut}/layer})];
		var miniMap = new L.Control.MiniMap(minimap_layer,{width: 100,height: 100}).addTo(map[(#GET{id})]);
		]

		// Pour Ajouter l'icone d'un point (feature = item d'un GeoJson)
		var setGeoJsonFeatureIcon = function (feature, layer) {
			// Déclarer l'icone du points, si défini
			if (feature.properties && feature.properties.icon){
				layer.setIcon(new L.Icon({
					iconUrl: feature.properties.icon,
					iconSize: new L.Point( feature.properties.icon_size\[0\], feature.properties.icon_size\[1\] ),
					iconAnchor: new L.Point( feature.properties.icon_anchor\[0\], feature.properties.icon_anchor\[1\] ),
					popupAnchor: new L.Point( feature.properties.popup_anchor\[0\], feature.properties.popup_anchor\[1\] )
				}));
			}
		}

		// Pour Ajouter le texte de popup d'un point (feature = item d'un GeoJson)
		var setGeoJsonFeaturePopup = function (feature, layer) {
			// Déclarer le contenu de la popup s'il y en a
			if (feature.properties && (feature.properties.title || feature.properties.description)){
				var popupContent = '';
				if (feature.properties.title)
					popupContent = '<strong class="title">' + feature.properties.title + '</strong>';
				if (feature.properties.description)
					popupContent = popupContent + feature.properties.description;
				layer.bindPopup(popupContent);
			}
		}

		[(#REM)
			Il y a pour le moment 2 façons d'analyser le GeoJson calculé
			en fonction de si on veut faire du clustering (regrouper les points proches)
			ou non. Il y a certainement moyen de regrouper en un seul élément
			la plupart du code, en se passant du js L.geoJson même hors clustering.
			À réfléchir.
		]
		<BOUCLE_fonction_analyse_json(CONDITION){si #ENV{cluster}|!={oui}}>
		// Analyse des points et déclaration (sans regroupement des points en cluster)
		var parseGeoJson = function(data, map) {
			var geojson = new L.geoJson('', {[
				style: (#ENV*{path_styles}|json_encode),
				]onEachFeature: function (feature, layer) {
					// Déclarer l'icone du point
					setGeoJsonFeatureIcon(feature, layer);
					// Déclarer le contenu de la popup s'il y en a
					setGeoJsonFeaturePopup(feature, layer);
				}
			}).addTo(map);
			geojson.addData(data);
			[(#ENV{autocenterandzoom,#ENV{centrer_auto}}|oui)
			map.fitBounds(geojson.getBounds());]
		}

		</BOUCLE_fonction_analyse_json>

		// Analyse des points et déclaration (en regroupant les points en cluster)
		var parseGeoJson = function(data,map) {
			markers = \[\];
			/* Pour chaque points présents, on crée un marqueur */
			$.each(data.features, function(i, feature) {
				if (feature.geometry.coordinates\[0\]) {
					var latlng = new L.LatLng(feature.geometry.coordinates\[1\], feature.geometry.coordinates\[0\]);
					var marker = new L.Marker(latlng);
					// Déclarer l'icone du point
					setGeoJsonFeatureIcon(feature, marker);
					// Déclarer le contenu de la popup s'il y en a
					setGeoJsonFeaturePopup(feature, marker);

					marker.id = feature.id;
					markers.push(marker);
				}
			});

			/* Ajout des marqueurs dans un clustering JS client */
			markerCluster = new L.Marker.Clusterer(map, markers, {[
				maxZoom: (#ENV{clusterMaxZoom, #ENV{maxZoom}|?{#ENV{maxZoom}|moins{2},''}}),][
				styles: \[[(#ENV*{clusterStyles}|json_encode)]\](#ENV*{clusterStyles}|oui)]
			});
		}
		<//B_fonction_analyse_json>


		<BOUCLE_definir_les_points_de_la_carte(CONDITION){si #ENV{point}|!={non}}>
		[(#REM)
			\#ENV{args} est présent uniquement lors de l'appel d'un modèle <carte_gis|...>
			dans un texte et contient alors les paramètres passés au modèle manuellement.
			On considère dans ce cas que seuls ces paramètres doivent calculer le json,
			et non pas aussi l'environnement automatique ajouté au modèle (comme objet, id_objet)
			dans lequel le modèle est appelé.
		]
		// Récupération des points à mettre sur la carte, via json externe
		jQuery.getJSON("[(#URL_PAGE{gis_json}|url_absolue)]",
			{[
				objets       : "(#ENV{objets,#ENV{class}}|trim)",]
				<BOUCLE_modeles_args_prioritaires(DATA){source table,#LISTE{
					id_objet, id_rubrique, id_secteur, id_parent,
					id_article, id_breve, id_document, id_mot,
					id_groupe, id_auteur, id_syndic, id_forum,
					id_gis, id_evenement
				}}>[#VALEUR : (#ENV{args}|?{#ENV{args/#VALEUR},#ENV{#VALEUR}}|trim),
				]</BOUCLE_modeles_args_prioritaires>[
				media        : "(#ENV{args}|?{#ENV{args/media},#ENV{media}}|trim)",][
				recherche    : "(#ENV{args}|?{#ENV{args/recherche},#ENV{recherche}})",][
				mots  : (#ENV{mots}|?{[(#ENV{mots}|trim|json_encode)],''}),][
				limit : (#ENV{limit,#ENV{limite,500}}|trim)][
				(#ENV{objets}|=={point_libre}|oui)
					[,lat : (#GET{lat}|trim)]
					[,lon : (#GET{lon}|trim)]
					[,titre : (#ENV{titre}|json_encode)]
					[,description : (#ENV{description}|json_encode)]
					[,icone : (#ENV{icone}|json_encode)]
				]
			},
			function(data) {
				if (data){
					// Charger le json (data) et déclarer les points
					parseGeoJson(data, map[(#GET{id})]);
				}
			}
		);
		</BOUCLE_definir_les_points_de_la_carte>


		<BOUCLE_test_kml(CONDITION){si (#ENV{kml}|oui)}>
			// Définir les couches KML ajoutées à la carte
			#SET{kml, #ENV{kml}}
			[(#GET{kml}|is_array|non) #SET{kml, #ARRAY{0,#GET{kml}}} ]
			<BOUCLE_kml(POUR){tableau #GET{kml}}>
				[(#VALEUR|intval|oui)
				var kml_#COMPTEUR_BOUCLE = new L.KML(['(#VALEUR|generer_url_entite{document}|url_absolue)'], {async: true}); ]
				[(#VALEUR|intval|non)
				var kml_#COMPTEUR_BOUCLE = new L.KML(['(#VALEUR|copie_locale)'], {async: true}); ]
				[(#ENV{centrer_fichier}|!={non}|et{#TOTAL_BOUCLE|>{1}|non})
				kml_#COMPTEUR_BOUCLE.on("loaded", function(e) { map[(#GET{id})].fitBounds(e.target.getBounds()); });]
				map[(#GET{id})].addLayer(kml_#COMPTEUR_BOUCLE);
			</BOUCLE_kml>
		</BOUCLE_test_kml>

		<BOUCLE_test_gpx(CONDITION){si (#ENV{gpx}|oui)}>
			// Définir les couches GPX ajoutées à la carte
			#SET{gpx, #ENV{gpx}}
			[(#GET{gpx}|is_array|non) #SET{gpx, #ARRAY{0,#GET{gpx}}} ]
			<BOUCLE_gpx(POUR){tableau #GET{gpx}}>
				[(#VALEUR|intval|oui)
				var gpx_#COMPTEUR_BOUCLE = new L.GPX(['(#VALEUR|generer_url_entite{document}|url_absolue)'], {async: true}); ]
				[(#VALEUR|intval|non)
				var gpx_#COMPTEUR_BOUCLE = new L.GPX(['(#VALEUR|copie_locale)'], {async: true}); ]
				[(#ENV{centrer_fichier}|!={non}|et{#TOTAL_BOUCLE|>{1}|non})
				gpx_#COMPTEUR_BOUCLE.on("loaded", function(e) { map[(#GET{id})].fitBounds(e.target.getBounds()); });]
				map[(#GET{id})].addLayer(gpx_#COMPTEUR_BOUCLE);
			</BOUCLE_gpx>
		</BOUCLE_test_gpx>

		[(#ENV{localize_visitor,#ENV{localiser_visiteur}}|oui)
		map[(#GET{id})].locate({setView: true, maxZoom: [(#ENV{zoom,#CONFIG{gis/zoom,0}})]});]

	}


	// Charger le javascript de GIS et initialiser la carte
	$(function(){
		jQuery.getScript(['(#CONFIG{auto_compress_js}|=={oui}|?{[(#PRODUIRE{fond=javascript/gis.js}|compacte)],[(#PRODUIRE{fond=javascript/gis.js})]})'],function(){
			[(#ENV{cluster}|=={oui}|oui)
				jQuery.getScript('[(#CHEMIN{javascript/leafclusterer.js}|compacte)]',function(){
			]
				if (typeof(callback_map[(#GET{id})]) === "function") {
					init_map[(#GET{id})](callback_map[(#GET{id})]);
				} else {
					init_map[(#GET{id})]();
				}
			[(#ENV{cluster}|=={oui}|oui)
				});
			]
		});
	});

})(jQuery);
/*\]\]>*/
</script>
