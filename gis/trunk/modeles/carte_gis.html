[(#REM)

	Modele carte_gis

	Parametres :

	- id_map|id_carte_gis = 1		id de la carte
	- lat|latit|latitude = 48.3		latitude du centre de la carte
	- lon|lonxit|longitude = -4.7		longitude du centre de la carte
	- zoom = 5				zoom de la carte
	- sw_lat = lat - 10°			latitude du sud-ouest de la bounding box
	- sw_lon = lon - 10°			longitude du sud-ouest de la bounding box
	- ne_lat = lat + 10°			latitude du nord-est de la bounding box
	- ne_lon = lon + 10°			longitude du nord-est de la bounding box
	- titre_carte				titre affiché au dessus la carte
	- width|largeur = 100%			largeur de la carte, 100% par defaut
	- height|hauteur = 400px		hauteur de la carte, 400px par defaut
	- style = non				ne pas styler la carte
	- zoom_molette|zoom_wheel = non		désactiver le zoom avec la molette de la souris, actif par defaut
	- fullscreen = oui			afficher un bouton pour passer la carte en plein écran
	- control_type|controle_type = non	ne pas afficher les controles de changement de type
	- no_control|aucun_controle = oui	ne pas afficher les controles de la carte
	- scale = oui				afficher l'échelle de la carte
	- overview = oui			afficher une mini carte de situation
	- limit|limite = 500			nombre max de marqueurs à afficher, 500 par defaut
	- objets = gis				type d'objets à afficher (fichier json/gis_xx qui génère la source de donnees)
	- autocenterandzoom|centrer_auto = oui	centrer et zoomer la carte automatiquement pour afficher tous les marqueurs
	- kml = 12				kml à superposer à la carte (id_document ou url)
	- gpx = 12				gpx à superposer à la carte (id_document ou url)
	- centrer_fichier = non			permet de ne pas centrer la carte automatiquement sur les fichiers kml/gpx surperposés
	- localize_visitor|localiser_visiteur = oui		centrer la carte sur la position du visiteur (API geolocation HTML5)
	- point = non				si elle vaut "non" cette option n'affichera pas de points du tout (utile pour n'afficher qu'un kml par exemple)
	- media = non				permet de passer le critère 'media' (pour les documents)
	- path_styles=#ARRAY{color,#fff}	options de style des éléments de la couche GeoJSON (voir http://leafletjs.com/reference.html#path-options)
	uniquement si objets = point_libre :
	- icone = chemin/vers/image		image utilisée pour le marker
	- titre					titre du point
	- description				description du point

]

[(#SET{width,#ENV{width,#ENV{largeur,100%}}})]
[(#SET{height,#ENV{height,#ENV{hauteur,400px}}})]
[(#SET{id,#ENV{id_carte_gis,#ENV{id_map,#ENV{id,1}}}})]
[(#REM) -- compat gis v1 -- ]
[(#SET{lat,#ENV{lat,#ENV{latit,#ENV{latitude,#CONFIG{gis/lat,0}}}}})]
[(#SET{lon,#ENV{lon,#ENV{lonxit,#ENV{longitude,#CONFIG{gis/lon,0}}}}})]
[(#REM) On utilise la bounding box seulement si le centre n'a pas été donné et si les quatre valeurs de la bounding box sont renseignées
    les valeurs par defaut sont "centre +/- 10°", ce qui est naze, mais c'est un cas normalement impossible
]
[(#ENV{lat}|ou{#ENV{lon}}|non|et{#ENV{sw_lat}}|et{#ENV{sw_lon}}|et{#ENV{ne_lat}}|et{#ENV{ne_lon}})
	#SET{utiliser_bb, oui}
	#SET{sw_lat,#ENV{sw_lat,#GET{lat}|moins{10}}}
	#SET{sw_lon,#ENV{sw_lon,#GET{lon}|moins{10}}}
	#SET{ne_lat,#ENV{ne_lat,#GET{lat}|plus{10}}}
	#SET{ne_lon,#ENV{ne_lon,#GET{lon}|plus{10}}}
]

[<h3>(#ENV{titre_carte})</h3>]
<div id="map[(#GET{id})]" class="carte_gis p"[(#ENV{style}|!={'non'}|?{' '})style="[width:(#GET{width});][ height:(#GET{height});]"]></div>

<script type="text/javascript">/*<!\[CDATA\[*/

var map[(#GET{id})];

(function($){
	
	var init_map[(#GET{id})] = function(callback) {
		var map_container = 'map[(#GET{id})]';
		
		map[(#GET{id})] = new L.Map(map_container,{
			scrollWheelZoom: [(#ENV{zoom_molette,#ENV{zoom_wheel}}|=={non}|?{false,true})],
			zoomControl: [(#ENV{no_control,#ENV{aucun_controle}}|!={oui}|?{true,false})]	
		});
		
		// appeler l'éventuelle fonction de callback
		if (callback && typeof(callback) === "function") {
			map[(#GET{id})].on('load',function(e){
				callback(e.target);
			});
		}
		
		[(#GET{utiliser_bb}|non)
		map[(#GET{id})].setView(new L.LatLng([(#GET{lat})], [(#GET{lon})]), [(#ENV{zoom,#CONFIG{gis/zoom,0}})]);]
		
		[(#GET{utiliser_bb}|oui)
		map[(#GET{id})].fitBounds(
			new L.LatLngBounds(
				new L.LatLng([(#GET{sw_lat})], [(#GET{sw_lon})]),
				new L.LatLng([(#GET{ne_lat})], [(#GET{ne_lon})])
			)
		);]
		
		//default layer
		#SET{layer_defaut,#REM|gis_layer_defaut} #SET{layers,#EVAL{$GLOBALS['gis_layers']}}
		var [(#GET{layer_defaut})] = [new (#GET{layers}|table_valeur{#GET{layer_defaut}/layer})];
		map[(#GET{id})].addLayer([(#GET{layer_defaut})]);
		
		<B_layers>
		var layers_control = new L.Control.Layers();
		layers_control.addBaseLayer([(#GET{layer_defaut})],["(#GET{layers}|table_valeur{#GET{layer_defaut}/nom})"]);
		<BOUCLE_layers(DATA){source table, #GET{layers}}{si #ENV{control_type,#ENV{controle_type}}|!={non}|et{#ENV{no_control,#ENV{aucun_controle}}|!={oui}}|et{#CONFIG{gis/layers,#ARRAY}|count|>{1}|oui}|oui}>[
		(#CLE|!={#GET{layer_defaut}}|oui|et{#CLE|in_array{#CONFIG{gis/layers,#ARRAY}}|oui}|oui)
		layers_control.addBaseLayer([new (#VALEUR|table_valeur{layer})],"[(#VALEUR|table_valeur{nom})]");]
		</BOUCLE_layers>
		map[(#GET{id})].addControl(layers_control);
		// ajouter l'objet du controle de layers à la carte pour permettre d'y accéder depuis le callback
		map[(#GET{id})].layersControl = layers_control;
		// classe noajax sur le layer_control pour éviter l'ajout de hidden par SPIP
		$(layers_control._form).addClass('noajax');
		</B_layers>
		
		map[(#GET{id})].setView(new L.LatLng(#GET{lat},#GET{lon}),#ENV{zoom,#CONFIG{gis/zoom,0}});
		
		map[(#GET{id})].attributionControl.setPrefix('');
		
		[(#ENV{scale}|et{#ENV{no_control,#ENV{aucun_controle}}|!={oui}}|oui)
		map[(#GET{id})].addControl(new L.Control.Scale());
		][(#ENV{fullscreen}|et{#ENV{no_control,#ENV{aucun_controle}}|!={oui}}|oui)
		map[(#GET{id})].addControl(new L.Control.FullScreen());
		][(#ENV{overview}|et{#ENV{no_control,#ENV{aucun_controle}}|!={oui}}|oui)
		var minimap_layer = [new (#GET{layers}|table_valeur{#GET{layer_defaut}/layer})];
		var miniMap = new L.Control.MiniMap(minimap_layer,{width: 100,height: 100}).addTo(map[(#GET{id})]);
		]

		[(#ENV{point}|!={non}|oui)
		jQuery.getJSON("[(#URL_PAGE{gis_json}|url_absolue)]",
			{[
				args : (#ENV{args,#ARRAY}|json_encode),][
				objets : "(#ENV{objets,#ENV{class}}|trim)",][
				id_objet : (#ENV{id_objet}|trim),][
				id_rubrique : (#ENV{id_rubrique}|trim),][
				id_secteur : (#ENV{id_secteur}|trim),][
				id_parent : (#ENV{id_parent}|trim),][
				id_article : (#ENV{id_article}|trim),][
				id_breve : (#ENV{id_breve}|trim),][
				id_document : (#ENV{id_document}|trim),][
				media : "(#ENV{media}|trim)",][
				id_mot : (#ENV{id_mot}|trim),][
				id_groupe : (#ENV{id_groupe}|trim),][
				id_auteur : (#ENV{id_auteur}|trim),][
				id_syndic : (#ENV{id_syndic}|trim),][
				id_forum : (#ENV{id_forum}|trim),][
				id_evenement : (#ENV{id_evenement}|trim),][
				id_gis : (#ENV{id_gis}|trim),][
				recherche : "(#ENV{recherche})",][
				mots : (#ENV{mots}|?{[(#ENV{mots}|trim|json_encode)],''}),][
				limit : (#ENV{limit,#ENV{limite,500}}|trim)][
				(#ENV{objets}|=={point_libre}|oui)
					[,lat : (#GET{lat}|trim)]
					[,lon : (#GET{lon}|trim)]
					[,titre : (#ENV{titre}|json_encode)]
					[,description : (#ENV{description}|json_encode)]
					[,icone : (#ENV{icone}|json_encode)]
				]
			},
			function(data) {
				if (data){
					var geojson = new L.geoJson('', {[
						style: (#ENV*{path_styles}|json_encode),
						]onEachFeature: function (feature, layer) {
							if (feature.properties && feature.properties.icon){
								layer.setIcon(new L.Icon({
									iconUrl: feature.properties.icon,
									iconSize: new L.Point( feature.properties.icon_size\[0\], feature.properties.icon_size\[1\] ),
									iconAnchor: new L.Point( feature.properties.icon_anchor\[0\], feature.properties.icon_anchor\[1\] )
								}));
							}
							if (feature.properties && (feature.properties.title || feature.properties.description)){
								var popupContent = '';
								if (feature.properties.title)
									popupContent = '<strong>' + feature.properties.title + '</strong>';
								if (feature.properties.description)
									popupContent = popupContent + feature.properties.description;
								layer.bindPopup(popupContent);
							}
						}
					}).addTo(map[(#GET{id})]);
					geojson.addData(data);
					[(#ENV{autocenterandzoom,#ENV{centrer_auto}}|oui)
					map[(#GET{id})].fitBounds(geojson.getBounds());]
				}
			}
		);]
		
		<BOUCLE_test_kml(CONDITION){si (#ENV{kml}|oui)}>
			#SET{kml, #ENV{kml}}
			[(#GET{kml}|is_array|non) #SET{kml, #ARRAY{0,#GET{kml}}} ]
			<BOUCLE_kml(POUR){tableau #GET{kml}}>
				[(#VALEUR|intval|oui)
				var kml_#COMPTEUR_BOUCLE = new L.KML(['(#VALEUR|generer_url_entite{document}|url_absolue)'], {async: true}); ]
				[(#VALEUR|intval|non)
				var kml_#COMPTEUR_BOUCLE = new L.KML(['(#VALEUR|copie_locale)'], {async: true}); ]
				[(#ENV{centrer_fichier}|!={non}|et{#TOTAL_BOUCLE|>{1}|non})
				kml_#COMPTEUR_BOUCLE.on("loaded", function(e) { map[(#GET{id})].fitBounds(e.target.getBounds()); });]
				map[(#GET{id})].addLayer(kml_#COMPTEUR_BOUCLE);
			</BOUCLE_kml>
		</BOUCLE_test_kml>
		<BOUCLE_test_gpx(CONDITION){si (#ENV{gpx}|oui)}>
			#SET{gpx, #ENV{gpx}}
			[(#GET{gpx}|is_array|non) #SET{gpx, #ARRAY{0,#GET{gpx}}} ]
			<BOUCLE_gpx(POUR){tableau #GET{gpx}}>
				[(#VALEUR|intval|oui)
				var gpx_#COMPTEUR_BOUCLE = new L.GPX(['(#VALEUR|generer_url_entite{document}|url_absolue)'], {async: true}); ]
				[(#VALEUR|intval|non)
				var gpx_#COMPTEUR_BOUCLE = new L.GPX(['(#VALEUR|copie_locale)'], {async: true}); ]
				[(#ENV{centrer_fichier}|!={non}|et{#TOTAL_BOUCLE|>{1}|non})
				gpx_#COMPTEUR_BOUCLE.on("loaded", function(e) { map[(#GET{id})].fitBounds(e.target.getBounds()); });]
				map[(#GET{id})].addLayer(gpx_#COMPTEUR_BOUCLE);
			</BOUCLE_gpx>
		</BOUCLE_test_gpx>
		
		[(#ENV{localize_visitor,#ENV{localiser_visiteur}}|oui)
		map[(#GET{id})].locate({setView: true, maxZoom: [(#ENV{zoom,#CONFIG{gis/zoom,0}})]});]
		
	}

	$(function(){
		jQuery.getScript(['(#CONFIG{auto_compress_js}|=={oui}|?{[(#PRODUIRE{fond=javascript/gis.js}|compacte)],[(#PRODUIRE{fond=javascript/gis.js})]})'],function(){
			if (typeof(callback_map[(#GET{id})]) === "function") {
				init_map[(#GET{id})](callback_map[(#GET{id})]);
			} else {
				init_map[(#GET{id})]();
			}
		});
	});

})(jQuery);
/*\]\]>*/
</script>
