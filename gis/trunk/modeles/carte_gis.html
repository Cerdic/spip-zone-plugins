[(#REM)

Modele carte_gis
----------------

Parametres possibles :

- id_map|id_carte_gis = 1          id de la carte
- lat|latit|latitude = 48.3        latitude du centre de la carte
- lon|lonxit|longitude = -4.7      longitude du centre de la carte
- zoom = 5                         zoom de la carte
- maxZoom = 13                     zoom maximum autorisé

- sw_lat = lat - 10°               latitude du sud-ouest de la bounding box
- sw_lon = lon - 10°               longitude du sud-ouest de la bounding box
- ne_lat = lat + 10°               latitude du nord-est de la bounding box
- ne_lon = lon + 10°               longitude du nord-est de la bounding box

- width|largeur = 100%             largeur de la carte, 100% par defaut
- height|hauteur = 400px           hauteur de la carte, 400px par defaut
- style = non                      ne pas styler la carte

- fullscreen = oui                     afficher un bouton pour passer la carte en plein écran
- zoom_molette|zoom_wheel = non        désactiver le zoom avec la molette de la souris, actif par defaut
- control_type|controle_type = non     ne pas afficher les controles de changement de type
- no_control|aucun_controle = oui      ne pas afficher les controles de la carte
- scale = oui                          afficher l'échelle de la carte
- overview = oui                       afficher une mini carte de situation

- autocenterandzoom|centrer_auto = oui        centrer et zoomer la carte automatiquement pour afficher tous les marqueurs
- localize_visitor|localiser_visiteur = oui   centrer la carte sur la position du visiteur (API geolocation HTML5)
- id_a_ouvrir                                 id_gis de l'infobulle à afficher au chargement(marqueur uniquement)

- objets = gis                     type d'objets à afficher (fichier json/gis_xx qui génère la source de donnees)
- limit|limite = 500               nombre max de marqueurs à afficher, 500 par defaut
- kml = 12                         kml à superposer à la carte (id_document ou url ou liste d'url)
- gpx = 12                         gpx à superposer à la carte (id_document ou url ou liste d'url)
- centrer_fichier = non            permet de ne pas centrer la carte automatiquement sur les fichiers kml/gpx surperposés
- point = non                      si elle vaut "non" cette option n'affichera pas de points du tout (utile pour n'afficher qu'un kml par exemple)

- media = non                      permet de passer le critère 'media' (pour les documents)
- mots = #LISTE{1,4,7}             plugin critere {mots} http://contrib.spip.net/Critere-mots
- path_styles=#ARRAY{color,#fff}   options de style des éléments de la couche GeoJSON (voir http://leafletjs.com/reference.html#path-options)

Uniquement si objets = point_libre :
- icone = chemin/vers/image        image utilisée pour le marker
- titre                            titre du point
- description                      description du point

Clustering (regroupement de points proches) :
- cluster = oui                    Active le clustering
- clusterMaxZoom = 11              Regroupe les points jusque à ce zoom, mais pas au delà
- clusterStyles = #ARRAY{}         Styles appliqués aux clusters

]

[(#SET{width,#ENV{width,#ENV{largeur,100%}}})]
[(#SET{height,#ENV{height,#ENV{hauteur,400px}}})]
[(#SET{id,#ENV{id_carte_gis,#ENV{id_map,#ENV{id,1}}}})]
[(#REM) -- compat gis v1 -- ]
[(#SET{lat,#ENV{lat,#ENV{latit,#ENV{latitude,#CONFIG{gis/lat,0}}}}})]
[(#SET{lon,#ENV{lon,#ENV{lonxit,#ENV{longitude,#CONFIG{gis/lon,0}}}}})]
[(#REM) On utilise la bounding box seulement si le centre n'a pas été donné et si les quatre valeurs de la bounding box sont renseignées
    les valeurs par defaut sont "centre +/- 10°", ce qui est naze, mais c'est un cas normalement impossible
]
[(#ENV{lat}|ou{#ENV{lon}}|non|et{#ENV{sw_lat}}|et{#ENV{sw_lon}}|et{#ENV{ne_lat}}|et{#ENV{ne_lon}})
	#SET{utiliser_bb, oui}
	#SET{sw_lat,#ENV{sw_lat,#GET{lat}|moins{10}}}
	#SET{sw_lon,#ENV{sw_lon,#GET{lon}|moins{10}}}
	#SET{ne_lat,#ENV{ne_lat,#GET{lat}|plus{10}}}
	#SET{ne_lon,#ENV{ne_lon,#GET{lon}|plus{10}}}
]

<div id="map[(#GET{id})]" class="carte_gis p"[(#ENV{style}|!={'non'}|?{' '})style="[width:(#GET{width});][ height:(#GET{height});]"]></div>

<script type="text/javascript">/*<!\[CDATA\[*/
var map[(#GET{id})];
var map_cfg = {
"mapid":"map[(#GET{id})]",
"scrollWheelZoom": [(#ENV{zoom_molette,#ENV{zoom_wheel}}|=={non}|?{false,true})],
"zoomControl": [(#ENV{no_control,#ENV{aucun_controle}}|!={oui}|?{true,false})][,
"maxZoom": (#ENV{maxZoom})],
"utiliser_bb":[(#GET{utiliser_bb}|?{true,false})],
"lat":[(#GET{lat})][,
"sw_lat":(#GET{sw_lat})][,
"ne_lat":(#GET{ne_lat})],
"lon":[(#GET{lon})][,
"sw_lon":(#GET{sw_lon})][,
"ne_lon":(#GET{ne_lon})],
"zoom":[(#ENV{zoom,#CONFIG{gis/zoom,0}})],
"default_layer":"[(#REM|gis_layer_defaut)]",
"layers":#EVAL{json_encode($GLOBALS['gis_layers'])},
"affiche_layers":[(#CONFIG{gis/layers,#ARRAY}|json_encode)],
"control_type":[(#ENV{control_type,#ENV{controle_type}}|=={non}|?{false,true})],
"no_control":[(#ENV{no_control,#ENV{aucun_controle}}|=={oui}|?{true,false})],
"scale":[(#ENV{scale}|=={oui}|?{true,false})],
"fullscreen":[(#ENV{fullscreen}|=={oui}|?{true,false})],
"cluster":[(#ENV{cluster}|=={oui}|?{true,false})],
"clusterMaxZoom":[(#ENV{clusterMaxZoom, #ENV{maxZoom}|?{#ENV{maxZoom}|moins{2},0}})],
"path_styles":[(#ENV*{path_styles}|json_encode)],
"autocenterandzoom":[(#ENV{autocenterandzoom,#ENV{centrer_auto}}|?{true,false})],
"open_id":"[(#ENV{id_a_ouvrir,''})]",
"clusterStyles":[(#ENV*{clusterStyles,#ARRAY}|json_encode)],
"affiche_points":[(#ENV{point,''}|=={non}|?{false,true})],
"json_points":{
	"url":"[(#URL_PAGE{gis_json}|url_absolue)]",
	"objets":"(#ENV{objets,#ENV{class}}|trim)",
	"limit":[(#ENV{limit,#ENV{limite,500}}|trim)],
	"env":[(#ENV{args,#ENV}|gis_modele_url_json_env|json_encode)][,
	"titre" : (#ENV{titre}|json_encode)][,
	"description" : (#ENV{description}|json_encode)][,
	"icone" : (#ENV{icone}|json_encode)]
	},
"localize_visitor":[(#ENV{localize_visitor,#ENV{localiser_visiteur}}|?{true,false})],
"kml":[(#ENV{kml,''}|?{[(#ENV{kml}|is_array|?{#ENV{kml},#LISTE{#ENV{kml}}}|gis_kml_to_urls|json_encode)],false})],
"gpx":[(#ENV{gpx,''}|?{[(#ENV{gpx}|is_array|?{#ENV{gpx},#LISTE{#ENV{gpx}}}|gis_kml_to_urls|json_encode)],false})]
};
if (typeof(callback_map[(#GET{id})]) === "function") {
	map_cfg['callback']=callback_map[(#GET{id})];
}

(function($){

	var gis_init_map = function(mapcfg) {
		var map_container = mapcfg["mapid"];

		// Création de la carte Leafleat
		var map = new L.Map(map_container,{
			scrollWheelZoom: mapcfg["scrollWheelZoom"],
			zoomControl: mapcfg["zoomControl"],
			maxZoom: mapcfg["maxZoom"]
		});
		// affecter sur la globale homonyme a mapid/map_container (compat ascendante)
		eval(map_container+"=map;");
		// affecter sur l'objet du DOM
		$("#"+map_container).get(0).map=map;

		// Appeler l'éventuelle fonction de callback et trigger "load"
		map.on('load',function(e){
			if (mapcfg["callback"] && typeof(mapcfg["callback"]) === "function") {
				var callback = mapcfg["callback"];
				callback(e.target);
			}
			$("#"+map_container).trigger('load',e.target);
		});

		// Déterminer la position initiale de la carte
		if (!mapcfg['utiliser_bb']){
			map.setView(new L.LatLng(mapcfg['lat'], mapcfg['lon']), mapcfg['zoom']);
		}
		else {
			map.fitBounds(
				new L.LatLngBounds(
					new L.LatLng(mapcfg['sw_lat'], mapcfg['sw_lon']),
					new L.LatLng(mapcfg['ne_lat'], mapcfg['ne_lon'])
				)
			);
		}

		var get_layer=function(name){
			var layer;
			if (typeof mapcfg['layers'][name]!=="undefined")
			eval("layer=new "+ mapcfg['layers'][name]["layer"]+";");
			return layer;
		}

		// Fond de carte par défaut (layer)
		var default_layer = get_layer(mapcfg['default_layer']);
		map.addLayer(default_layer);

		if (mapcfg['control_type'] && !mapcfg['no_control'] && mapcfg['affiche_layers'].length>1){
			var layers_control = new L.Control.Layers();
			layers_control.addBaseLayer(default_layer,mapcfg['layers'][mapcfg['default_layer']]["nom"]);
			for(var l in mapcfg['affiche_layers']){
				if (mapcfg['affiche_layers'][l]!==mapcfg['default_layer']){
					var layer = get_layer(mapcfg['affiche_layers'][l]);
					if (typeof layer!=="undefined")
						layers_control.addBaseLayer(layer,mapcfg['layers'][mapcfg['affiche_layers'][l]]["nom"]);
				}
			}
			map.addControl(layers_control);
			// ajouter l'objet du controle de layers à la carte pour permettre d'y accéder depuis le callback
			map.layersControl = layers_control;
			// classe noajax sur le layer_control pour éviter l'ajout de hidden par SPIP
			$(layers_control._form).addClass('noajax');
		}

		map.setView(new L.LatLng(mapcfg['lat'],mapcfg['lon']),mapcfg['zoom']);
		map.attributionControl.setPrefix('');

		// Ajout des contrôles de la carte
		if (!mapcfg['no_control']){
			if (mapcfg['scale'])
				map.addControl(new L.Control.Scale());
			if (mapcfg['fullscreen'])
				map.addControl(new L.Control.FullScreen());
			if (mapcfg['overview']){
				var minimap_layer = get_layer(mapcfg['default_layer']);
				var miniMap = new L.Control.MiniMap(minimap_layer,{width: 100,height: 100}).addTo(map);
			}
		}

		// API setGeoJsonFeatureIcon : Pour Ajouter l'icone d'un point (feature = item d'un GeoJson)
		map.setGeoJsonFeatureIcon = function (feature, layer) {
			// Déclarer l'icone du points, si défini
			if (feature.properties && feature.properties.icon){
				layer.setIcon(new L.Icon({
					iconUrl: feature.properties.icon,
					iconSize: new L.Point( feature.properties.icon_size[0], feature.properties.icon_size[1] ),
					iconAnchor: new L.Point( feature.properties.icon_anchor[0], feature.properties.icon_anchor[1] ),
					popupAnchor: new L.Point( feature.properties.popup_anchor[0], feature.properties.popup_anchor[1] )
				}));
			}
		}

		// API setGeoJsonFeaturePopup : Pour Ajouter le texte de popup d'un point (feature = item d'un GeoJson)
		map.setGeoJsonFeaturePopup = function (feature, layer) {
			// Déclarer le contenu de la popup s'il y en a
			if (feature.properties && (feature.properties.title || feature.properties.description)){
				var popupContent = '';
				if (feature.properties.title)
					popupContent = '<strong class="title">' + feature.properties.title + '</strong>';
				if (feature.properties.description)
					popupContent = popupContent + feature.properties.description;
				layer.bindPopup(popupContent);
			}
		}

		/*
			Il y a pour le moment 2 façons d'analyser le GeoJson calculé
			en fonction de si on veut faire du clustering (regrouper les points proches)
			ou non. Il y a certainement moyen de regrouper en un seul élément
			la plupart du code, en se passant du js L.geoJson même hors clustering.
			À réfléchir.
		*/
		// API parseGeoJson
		if (!mapcfg['cluster']){
			// Analyse des points et déclaration (sans regroupement des points en cluster)
			map.parseGeoJson = function(data) {
				var geojson = new L.geoJson('', {
					style: mapcfg['path_styles'],
					onEachFeature: function (feature, layer) {
						// Déclarer l'icone du point
						map.setGeoJsonFeatureIcon(feature, layer);
						// Déclarer le contenu de la popup s'il y en a
						map.setGeoJsonFeaturePopup(feature, layer);
					}
				}).addTo(map);
				geojson.addData(data);
				if (mapcfg['autocenterandzoom'])
					map.fitBounds(geojson.getBounds());
				if (mapcfg['open_id'].length)
					gis_focus_marker(mapcfg['open_id'],map_container);
			}
		}
		else {
			// Analyse des points et déclaration (en regroupant les points en cluster)
			map.parseGeoJson = function(data) {
				map.markers = [];
				/* Pour chaque points présents, on crée un marqueur */
				$.each(data.features, function(i, feature) {
					if (feature.geometry.coordinates[0]) {
						var latlng = new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);
						var marker = new L.Marker(latlng);
						// Déclarer l'icone du point
						map.setGeoJsonFeatureIcon(feature, marker);
						// Déclarer le contenu de la popup s'il y en a
						map.setGeoJsonFeaturePopup(feature, marker);

						marker.id = feature.id;
						map.markers.push(marker);
					}
				});
				/* Ajout des marqueurs dans un clustering JS client */
				var options = {};
				if (mapcfg["clusterMaxZoom"])
					options["maxZoom"] = mapcfg["clusterMaxZoom"];
				if (mapcfg["clusterStyles"].length)
					options["styles"] = mapcfg["clusterStyles"];
				map.markerCluster = new L.Marker.Clusterer(map, markers, options);
			}
		}

		// API Compat Gis3 : addJSON et removeAllMarkers
		map.addJSON = map.parseGeoJson
		map.removeAllMarkers = function(){
			for(l in this._layers)
			if (this._layers[l]._layers){
			 this.removeLayer(this._layers[l]);
			}
		}

		if (mapcfg['affiche_points'] && mapcfg['json_points'].length){
			// Récupération des points à mettre sur la carte, via json externe
			var args = mapcfg['json_points']['env'];
			args["objets"] = mapcfg['json_points']['objets'];
			args["limit"] = mapcfg['json_points']['limit'];
			if (args["objets"]=="point_libre"){
				args["lat"]=mapcfg['lat'];
				args["lon"]=mapcfg['lon'];
				args["titre"]=mapcfg['json_points']['titre'];
				args["description"]=mapcfg['json_points']['description'];
				args["icone"]=mapcfg['json_points']['icone'];
			}
			jQuery.getJSON(mapcfg['json_points']['url'],args,
				function(data) {
					if (data){
						// Charger le json (data) et déclarer les points
						map.parseGeoJson(data);
						$("#"+map_container).trigger('ready',map);
					}
				}
			);
		}

		if (mapcfg['kml'] && mapcfg['kml'].length){
			map.kml = {};
			for(var i in mapcfg['kml']){
				map.kml[i] = new L.KML(mapcfg['kml'][i], {async: true});
				map.kml[i].on("loaded", function(e) { map.fitBounds(e.target.getBounds()); });
				map.addLayer(map.kml[i]);
			}
		}
		if (mapcfg['gpx'] && mapcfg['gpx'].length){
			map.gpx = {};
			for(var i in mapcfg['gpx']){
				map.gpx[i] = new L.GPX(mapcfg['gpx'][i], {async: true});
				map.gpx[i].on("loaded", function(e) { map.fitBounds(e.target.getBounds()); });
				map.addLayer(map.gpx[i]);
			}
		}

		if (mapcfg['localize_visitor'])
			map.locate({setView: true, maxZoom: mapcfg['zoom']});

		// si pas de points trigger ici
		if (!mapcfg['affiche_points'] || !mapcfg['json_points'].length)
			$("#"+map_container).trigger('ready',map);
	}


	// Charger le javascript de GIS et initialiser la carte
	$(function(){
		jQuery.getScript('[(#PRODUIRE{fond=javascript/gis.js,cluster=#ENV{cluster,non}})]',function(){
			gis_init_map(map_cfg);
		});
	});

})(jQuery);
/*\]\]>*/
</script>
