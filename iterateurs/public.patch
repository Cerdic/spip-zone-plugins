--- public/compiler.php	2010-12-26 23:00:47.000000000 +0100
+++ ../../ecrire/public/compiler.php	2010-12-26 20:04:39.000000000 +0100
@@ -189,131 +189,15 @@ function calculer_inclure($p, &$boucles,
 	return	"\n'<'.'".	"?php ". $code . "\n?'." . "'>'";
 }
 
+//
+// calculer_boucle() produit le corps PHP d'une boucle Spip. 
+// ce corps remplit une variable $t0 retournee en valeur.
+// Ici on distingue boucles recursives et boucle a requete SQL
+// et on insere le code d'envoi au debusqueur du resultat de la fonction.
 
-/**
- * Calculer la clause where pour filtrer les status,
- *
- * @param string $mstatut
- *  le champ de la table sur lequel porte la condition
- * @param string $liste
- *  statut ou liste des statuts separes par une virgule
- * @return array
- */
-function calculer_where_statut($mstatut,$liste){
-	$not = false;
-	if (strncmp($liste,'!',1)==0){
-		$not = true;
-	  $liste = substr($liste,1);
-	}
-	// '' => ne rien afficher, '!'=> ne rien filtrer
-	if (!strlen($liste))
-		return ($not?"'1=1'":"'0=1'");
-
-	$liste = explode(',',$liste);
-	foreach($liste as $k=>$v) {
-		$liste[$k] = "\\'".preg_replace(",\W,","",$v)."\\'";
-	}
-  if (count($liste)==1){
-		return array($not?"'<>'":"'='", "'$mstatut'", "'".reset($liste)."'");
-  }
-  else {
-	  return array($not?"'NOT IN'":"'IN'", "'$mstatut'", "'(".implode(',',$liste).")'");
-  }
-}
-
-/**
- * calculer_boucle() produit le corps PHP d'une boucle Spip.
- * ce corps remplit une variable $t0 retournee en valeur.
- * Ici on distingue boucles recursives et boucle a requete SQL
- * et on insere le code d'envoi au debusqueur du resultat de la fonction.
- *
- * http://doc.spip.org/@calculer_boucle
- *
- * @param  $id_boucle
- * @param  $boucles
- * @return string
- */
+// http://doc.spip.org/@calculer_boucle
 function calculer_boucle($id_boucle, &$boucles) {
 
-	// gerer les statuts si declares pour cette table
-	/*
-	$table_statut[nom_table][] = array(
-		'champ'=>'statut',  // champ de la table sur lequel porte le filtrage par le statut
-		'publie'=>'publie', // valeur ou liste de valeurs, qui definissent l'objet comme publie.
-		'previsu'=>'publie,prop', // valeur ou liste de valeurs qui sont visibles en previsu
-		'post_date'=>'date', // un champ de date pour la prise en compte des post_dates, ou rien sinon
-	  'exception'=>'statut', // liste des modificateurs qui annulent le filtrage par statut
-	                         // si plusieurs valeurs : array('statut','tout','lien')
-	);
-
-	Pour 'publier' ou 'previsu', si la chaine commence par un "!" on exclu au lieu de filtrer sur les valeurs donnees
-	si la chaine est vide, on ne garde rien si elle est seulement "!" on n'exclu rien
-
-	Si le statut repose sur une jointure, 'champ' est alors un tableau du format suivant :
-	'champ'=>array(
-	    array(table1, cle1),
-	    ...
-	    array(tablen, clen),
-	    champstatut
-	 )
-
-	champstatut est alors le champ statut sur la tablen
-	dans les jointures, clen peut etre un tableau pour une jointure complexe : array('id_objet','id_article','objet','article')	 
-	*/
-
-	$boucle = &$boucles[$id_boucle];
-	$id_table = $boucle->id_table;
-	$table_sql = $boucle->from[$id_table];
-	if (isset($GLOBALS['table_statut'][$table_sql])){
-		foreach($GLOBALS['table_statut'][$table_sql] as $s){
-			// Restreindre aux elements publies si pas de {statut} ou autre dans les criteres
-			$filtrer = true;
-			if (isset($s['exception'])) {
-				foreach(is_array($s['exception'])?$s['exception']:array($s['exception']) as $m) {
-					if (isset($boucle->modificateur[$m]) OR isset($boucle->modificateur['criteres'][$m])) {
-						$filtrer = false;
-						break;
-					}
-				}
-			}
-
-			if ($filtrer) {
-				if (is_array($s['champ'])){
-					$statut = preg_replace(',\W,','',array_pop($s['champ'])); // securite
-					$jointures = array();
-					foreach($s['champ'] as $j) {
-						$jointures[] = array('',array($id=reset($j)),end($j));
-					}
-					$jointures[0][0] = $id_table;
-					if (!array_search($id, $boucle->from)){
-						fabrique_jointures($boucle, $jointures, true, $boucle->show, $id_table);
-					}
-					// trouver l'alias de la table d'arrivee qui porte le statut
-					$id = array_search($id, $boucle->from);
-				}
-				else {
-					$id = $id_table;
-					$statut = preg_replace(',\W,','',$s['champ']); // securite
-				}
-				$mstatut = $id .'.'.$statut;
-
-				if (!$GLOBALS['var_preview']) {
-					if (isset($s['post_date']) AND $s['post_date']
-						AND $GLOBALS['meta']["post_dates"] == 'non'){
-						$date = $id.'.'.preg_replace(',\W,','',$s['post_date']); // securite
-						array_unshift($boucle->where,"quete_condition_postdates('$date')");
-					}
-					array_unshift($boucle->where,calculer_where_statut($mstatut,$s['publie']));
-				}
-				else {
-					array_unshift($boucle->where,calculer_where_statut($mstatut,$s['previsu']));
-				}
-			}
-		}
-	}
-
-
-
 	$boucles[$id_boucle] = pipeline('post_boucle', $boucles[$id_boucle]);
 
 	// en mode debug memoriser les premiers passages dans la boucle,
@@ -358,16 +242,13 @@ function calculer_boucle_rec($id_boucle,
 define('CODE_CORPS_BOUCLE', '%s
 	$t0 = "";
 	// REQUETE
-	$iter = IterFactory::create(
-		"%s",
-		%s,
-		array(%s)
-	);
-	if (!$iter->err()) {
+	$result = calculer_select($select, $from, $type, $where, $join, $groupby, $orderby, $limit, $having, $table, $id, $connect,
+		 array(%s));
+	if ($result) {
 	%s%s$SP++;
 	// RESULTATS
 	%s
-	%s$iter->free();
+	%s@sql_free($result%s);
 	}%s
 	return $t0;'
 );
@@ -391,9 +272,9 @@ function calculer_boucle_nonrec($id_bouc
 		. "; // doublons\n";
 
 	// La boucle doit-elle selectionner la langue ?
-	// - par defaut, les boucles suivantes le font
+	// -. par defaut, les boucles suivantes le font
 	//    (sauf si forcer_lang==true ou si le titre contient <multi>).
-	// - a moins d'une demande explicite via {!lang_select}
+	// - . a moins d'une demande explicite via {!lang_select}
 	if (!$constant && $boucle->lang_select != 'non' &&
 	    (($boucle->lang_select == 'oui')  ||
 		    in_array($type_boucle, array(
@@ -461,6 +342,9 @@ function calculer_boucle_nonrec($id_bouc
 		. $boucle->partie 
 		. $corps;
 
+	$serveur = !$boucle->sql_serveur ? ''
+		: (', ' . _q($boucle->sql_serveur));
+
 	// si le corps est une constante, ne pas appeler le serveur N fois!
 
 	if (preg_match(CODE_MONOTONE,str_replace("\\'",'',$corps), $r)) {
@@ -473,7 +357,7 @@ function calculer_boucle_nonrec($id_bouc
 			$boucle->numrows = true;
 			$corps = "\n\t\$t0 = str_repeat($corps, \$Numrows['$id_boucle']['total']);";
 		}
-	} else $corps = "while (\$Pile[\$SP]=\$iter->fetch()) {\n$corps\n	}"; 
+	} else $corps = "while (\$Pile[\$SP] = @sql_fetch(\$result$serveur)) {\n$corps\n	}"; 
 
 	$count = '';
 	if (!$boucle->select) {
@@ -490,8 +374,8 @@ function calculer_boucle_nonrec($id_bouc
 
 	if ($boucle->numrows OR $boucle->mode_partie) {
 		if ($count == 'count(*)')
-			$count = "array_shift(\$iter->next())";
-		else $count = "\$iter->count()";
+			$count = "array_shift(sql_fetch(\$result$serveur))";
+		else $count = "sql_count(\$result$serveur)";
 		$nums .= "\$Numrows['$id_boucle']['total'] = @intval($count);"
 		. $boucle->mode_partie
 		. "\n\t";
@@ -506,20 +390,7 @@ function calculer_boucle_nonrec($id_bouc
 
 	$contexte = memoriser_contexte_compil($boucle);
 
-	$a = sprintf(CODE_CORPS_BOUCLE,
-		$init,
-		$boucle->iterateur,
-		"\$command",
-		$contexte,
-		$nums,
-		$init_lang,
-		$corps,
-		$fin_lang,
-		$trace
-	);
-
-#	var_dump($a);exit;
-	return $a;
+	return sprintf(CODE_CORPS_BOUCLE, $init, $contexte, $nums, $init_lang, $corps, $fin_lang, $serveur, $trace);
 }
 
 
@@ -529,20 +400,20 @@ function calculer_requete_sql($boucle)
 	return ($boucle->hierarchie ? "\n\t$boucle->hierarchie" : '')
 	  . $boucle->in 
 	  . $boucle->hash 
-	  . calculer_dec('table',  "'" . $boucle->id_table ."'")
-	  . calculer_dec('id', "'" . $boucle->id_boucle ."'")
+	  . calculer_dec('$table',  "'" . $boucle->id_table ."'")
+	  . calculer_dec('$id', "'" . $boucle->id_boucle ."'")
 		# En absence de champ c'est un decompte : 
-	  . calculer_dec('from',  calculer_from($boucle))
-	  . calculer_dec('type', calculer_from_type($boucle))
-	  . calculer_dec('groupby', 'array(' . (($g=join("\",\n\t\t\"",$boucle->group))?'"'.$g.'"':'') . ")")
-	  . calculer_dec('select', 'array("' . join("\",\n\t\t\"", $boucle->select).  "\")")
-	  . calculer_dec('orderby', 'array(' . calculer_order($boucle) .	")")
-	  . calculer_dec('where', calculer_dump_array($boucle->where))
-	  . calculer_dec('join', calculer_dump_join($boucle->join))
-	  . calculer_dec('limit', (strpos($boucle->limit, 'intval') === false ?
+	  . calculer_dec('$from',  calculer_from($boucle))
+	  . calculer_dec('$type', calculer_from_type($boucle))
+	  . calculer_dec('$groupby', 'array(' . (($g=join("\",\n\t\t\"",$boucle->group))?'"'.$g.'"':'') . ")")
+	  . calculer_dec('$select', 'array("' . join("\",\n\t\t\"", $boucle->select).  "\")")
+	  . calculer_dec('$orderby', 'array(' . calculer_order($boucle) .	")")
+	  . calculer_dec('$where', calculer_dump_array($boucle->where))
+	  . calculer_dec('$join', calculer_dump_join($boucle->join))
+	  . calculer_dec('$limit', (strpos($boucle->limit, 'intval') === false ?
 				    "'".$boucle->limit."'" :
 				    $boucle->limit))
-	  . calculer_dec('having', calculer_dump_array($boucle->having));
+	  . calculer_dec('$having', calculer_dump_array($boucle->having));
 }
 
 function memoriser_contexte_compil($p) {
@@ -570,20 +441,20 @@ function reconstruire_contexte_compil($c
 // http://doc.spip.org/@calculer_dec
 function calculer_dec($nom, $val)
 {
-	$static = 'if (!isset($command[\''.$nom.'\'])) ';
-	if (
-		strpos($val, '$') !== false 
-		OR strpos($val, 'sql_') !== false
-		OR (
-			$test = str_replace(array("array(",'\"',"\'"),array("","",""),$val) // supprimer les array( et les echappements de guillemets
-			AND strpos($test,"(")!==FALSE // si pas de parenthese ouvrante, pas de fonction, on peut sortir
-			AND $test = preg_replace(",'[^']*',UimsS","",$test) // supprimer les chaines qui peuvent contenir des fonctions SQL qui ne genent pas
-			AND preg_match(",\w+\s*\(,UimsS",$test,$regs) // tester la presence de fonctions restantes
-		)
-	)
-		$static = "";
-
-	return "\n\t" . $static . '$command[\''.$nom.'\'] = ' . $val . ';';
+	$static = "static ";
+  if (
+    strpos($val, '$') !== false 
+    OR strpos($val, 'sql_') !== false
+    OR (
+    	$test = str_replace(array("array(",'\"',"\'"),array("","",""),$val) // supprimer les array( et les echappements de guillemets
+    	AND strpos($test,"(")!==FALSE // si pas de parenthese ouvrante, pas de fonction, on peut sortir
+    	AND $test = preg_replace(",'[^']*',UimsS","",$test) // supprimer les chaines qui peuvent contenir des fonctions SQL qui ne genent pas
+    	AND preg_match(",\w+\s*\(,UimsS",$test,$regs) // tester la presence de fonctions restantes
+    )
+    ){
+    $static = "";
+  }
+  return "\n\t" . $static . $nom . ' = ' . $val . ';';
 }
 
 // http://doc.spip.org/@calculer_dump_array
@@ -963,36 +834,14 @@ function compiler_squelette($squelette, 
 			// si la table n'existe pas avec le connecteur par defaut, 
 			// c'est peut etre une table qui necessite son connecteur dedie fourni
 			// permet une ecriture allegee (GEO) -> (geo:GEO)
-			if (!$show
-			AND $show=$trouver_table($type, strtolower($type))) {
+			if (!$show AND $show=$trouver_table($type, strtolower($type)))
 				$boucles[$id]->sql_serveur = strtolower($type);
-			}
-
-			// chercher dans les iterateurs du repertoire iterateur/
-			if ($g = charger_fonction(
-			preg_replace('/\W/', '_', $boucle->type_requete), 'iterateur', true)) {
-				$boucles[$id] = $g($boucle);
-
-			// sinon, en cas de requeteur "php" existe-t-il un iterateur PHP
-			} else if ($boucle->sql_serveur == 'php') {
-				if (class_exists($boucle->type_requete)) {
-					$g = charger_fonction('php', 'iterateur');
-					$boucles[$id] = $g($boucle, $boucle->type_requete);
-				} else {
-					$x = $boucle->type_requete;
-					$boucle->type_requete = false;
-					$msg = array('zbug_iterateur_inconnu',
-							array('iterateur' => $x));
-					erreur_squelette($msg, $boucle);
-				}
-			// utiliser la description des champs transmis
-			} else if ($show) {
+			if ($show) {
 				$boucles[$id]->show = $show;
 				// recopie les infos les plus importantes
 				$boucles[$id]->primary = $show['key']["PRIMARY KEY"];
 				$boucles[$id]->id_table = $x = $show['id_table'];
 				$boucles[$id]->from[$x] = $nom_table = $show['table'];
-				$boucles[$id]->iterateur = 'SQL';
 
 				$boucles[$id]->descr = &$descr;
 				if ((!$boucles[$id]->jointures)
@@ -1090,7 +939,7 @@ function compiler_squelette($squelette, 
 			// laquelle a une definition par defaut
 			if (!function_exists($f)) $f = 'boucle_DEFAUT';
 			if (!function_exists($f)) $f = 'boucle_DEFAUT_dist';
-			$req = "\n\n\tstatic \$command = array();\n\t\$command['connect'] = " .
+			$req = "\n\n\tstatic \$connect = " .
 				_q($boucle->sql_serveur) .
 				";" .
 				$f($id, $boucles);
--- public/criteres.php	2010-12-26 23:15:28.000000000 +0100
+++ ../../ecrire/public/criteres.php	2010-12-26 20:04:39.000000000 +0100
@@ -927,8 +927,7 @@ function calculer_critere_infixe($idb, &
 		  $table = calculer_critere_externe_init($boucle, array($table), $col, $desc, ($crit->cond OR $op !='='), true);
 		  if (!$table) return '';
 	}
-	elseif (@!array_key_exists($col, $desc['field'])
-	AND @!array_key_exists('*', $desc['field'])) {
+	elseif (@!array_key_exists($col, $desc['field'])) {
 		$r = calculer_critere_infixe_externe($boucle, $crit, $op, $desc, $col, $col_alias, $table);
 		if (!$r) return '';
 		list($col, $col_alias, $table, $where_complement) = $r;
--- public/interfaces.php	2010-12-26 22:58:28.000000000 +0100
+++ ../../ecrire/public/interfaces.php	2010-12-26 20:04:39.000000000 +0100
@@ -10,6 +10,7 @@
  *  Pour plus de details voir le fichier COPYING.txt ou l'aide en ligne.   *
 \***************************************************************************/
 
+
 if (!defined('_ECRIRE_INC_VERSION')) return;
 
 
@@ -79,7 +80,6 @@ class Boucle {
 	var $cptrows = false;
 	var $ligne = 0;
 	var $descr =  array(); # noms des fichiers source et but etc
-	var $iterateur = ''; // type d'iterateur
 
 	var $modificateur = array(); // table pour stocker les modificateurs de boucle tels que tout, plat ..., utilisable par les plugins egalement
 
--- public/phraser_html.php	2010-12-26 22:50:00.000000000 +0100
+++ ../../ecrire/public/phraser_html.php	2010-12-26 20:04:39.000000000 +0100
@@ -35,7 +35,7 @@ define('BALISE_POLYGLOTTE',',<multi>(.*)
 define('BALISE_IDIOMES',',<:(([a-z0-9_]+):)?([a-z0-9_]+)({([^\|=>]*=[^\|>]*)})?((\|[^>]*)?:>),iS');
 
 define('SQL_ARGS', '(\([^)]*\))');
-define('CHAMP_SQL_PLUS_FONC', '`?([A-Z_\/][A-Z_\/0-9.]*)' . SQL_ARGS . '?`?');
+define('CHAMP_SQL_PLUS_FONC', '`?([A-Z_][A-Z_0-9.]*)' . SQL_ARGS . '?`?');
 
 // http://doc.spip.org/@phraser_inclure
 function phraser_inclure($texte, $ligne, $result) {
@@ -447,8 +447,9 @@ function phraser_criteres($params, &$res
 // plus d'un argument et pas le critere IN:
 // detecter comme on peut si c'est le critere implicite LIMIT debut, fin
 
-			if ($var->type != 'texte'
-			OR preg_match("/^(n|(n-)?\d+)$/S", $param)) {
+			if (($var->type != 'texte') ||
+			    (strpos("0123456789-", $param[strlen($param)-1])
+			     !== false)) {
 			  $op = ',';
 			  $not = "";
 			} else {
@@ -460,14 +461,8 @@ function phraser_criteres($params, &$res
 			  // et mettre son reliquat eventuel
 			  // Recopier pour ne pas alterer le texte source
 			  // utile au debusqueur
+
 			  if ($m[3]) {
-			    // une maniere tres sale de supprimer les "' autour de {critere "xxx","yyy"}
-			    if (preg_match(',^(["\'])(.*)\1$,', $m[3])) {
-			    	$c = null;
-			    	eval ('$c = '.$m[3].';');
-			    	if (isset($c))
-			    		$m[3] = $c;
-			    }
 			    $texte = new Texte;
 			    $texte->texte = $m[3]; 
 			    $v[1][0]= $texte;
--- public/references.php	2010-12-26 22:52:42.000000000 +0100
+++ ../../ecrire/public/references.php	2010-12-26 20:04:39.000000000 +0100
@@ -82,9 +82,6 @@ function index_tables_en_pile($idb, $nom
 		if (isset($desc['field'][$nom_champ])) {
 			$t = $boucles[$idb]->id_table;
 			return array("$t.$nom_champ", $nom_champ);
-		} else if (isset($desc['field']['*'])) {
-			$t = $boucles[$idb]->id_table;
-			return array($nom_champ, $nom_champ);
 		} else {
 		  if ($boucles[$idb]->jointures_explicites) {
 		    $t = trouver_champ_exterieur($nom_champ, 
