// désérialiser $meta['prefix_plugin'] en un array $prefix_plugin à partir des données de spip_meta
      	$prefix = 'saveauto';
      	include_spip('inc/meta');
      	lire_metas();
      	global $meta;
      	$meta_prefix = 'meta'.'_'.$prefix;
      	$$meta_prefix = unserialize($meta[$prefix]);
// récupérer les $prefix_meta['nom_variable' => 'valeur_variable', ...] 
// sous la forme : $nom_variable = 'valeur_variable'				
      	foreach ($$meta_prefix as $cle => $valeur) {
      	 			  $$cle = $valeur;
       }

REMPLACE PAR
        lire_cfg()
================================================================================       


(12:52:39) cy_altern: ...donc même si cfg ne produit pas de balises dynamiques, finalement on s'en f*** : 
il suffit de le passer la valeur de #CONFIG{prefix_plugin/nom_variable} dans #SET{var_cfg,[(#CONFIG{prefix_plugin/nom_variable})]} 
et d'utiliser ensuite #GET{var_cfg}
		 [(#SET{id_aa,[(#CONFIG{aa/id_aa})]})] 
		 <INCLURE{fond=aa}{id_article=(#GET{id_aa})}>

REMPLACE PAR 
     [(#INCLURE{fond=aa}{id_article=[(#CONFIG{aa/id_aa})]})]
     
POSSIBLE AUSSI SANS #INCLURE : BOUCLE avec {id_article=(#CONFIG{aa/id_aa})}

[(#REM) test plugin aa]
<div class="liste-articles">			
		 <BOUCLE_truc(ARTICLES){id_article=(#CONFIG{aa/id_aa})}>
    			<div class="cartouche">
    				#DEBUT_SURLIGNE
    				[(#CONFIG{aa/logo}|=={on}|?{[(#LOGO_ARTICLE||image_reduire{200,200})],''})]
    				[(#CONFIG{aa/titre}|=={on}|?{[<h1 class="#EDIT{titre} titre">(#TITRE)</h1>],''})]
    				[(#CONFIG{aa/soustitre}|=={on}|?{[<p class="#EDIT{soustitre} soustitre">(#SOUSTITRE)</p>],''})]
    				[(#CONFIG{aa/chapo}|=={on}|?{[<p class="#EDIT{chapo} chapo">(#CHAPO)</p>],''})]
    				#FIN_SURLIGNE
    			</div>
				  [(#CONFIG{aa/texte}|=={on}|?{[<div class="#EDIT{texte} texte">(#TEXTE|image_reduire{520,0})</div>],''})]		 		
		 </BOUCLE_truc>
</div>

================================================================================

(02:21:22) cy_altern: toggg : pour cfg, le nom du fichier qu'il faut créer dans le plugin c'est fonds/cfg_prefix_du_plugin.html ?
(02:21:41) toggg: oué
(02:22:02) toggg: enfin prefix que tu veux
(02:22:44) cy_altern: et après ça se passe comment ? tu envoie tes données dans un form et cfg il te fait la sérialisation dans meta automatiquement... :)
(02:22:52) toggg: apres c'est exec=cfg&cfg=prefix
(02:23:09) toggg: ça fait tout
(02:23:38) cy_altern: comment tu récupère les données sérialisées ?
(02:24:38) cy_altern: pour les transformer en variables php ? [(#CONFIG{prefix_plugin/nom_variable_de_config})]  ?
(02:24:48) cy_altern: c'est ça ?
(02:25:08) toggg: si cfg est installé
(02:25:31) toggg: sinon c'est le gros hack ci dessus
(02:25:38) toggg: en php c'est
(02:25:44) cy_altern: arf ! cfg il va vite fait se retrouver dans le core si c'est un peu généraliste ton truc :)
(02:26:55) cy_altern: et dans l'interface privée, comment tu récupère les données de #CONFIG ? $config[prefix_plugin][nom_variable_de_config]  ?
(02:27:58) cy_altern: c'est un truc comme ça ?
(02:28:00) toggg: 	include_spip('inc/meta');
(02:28:00) toggg: 	lire_metas();
(02:28:00) toggg: 	global $meta;
(02:28:00) toggg: 	$metacrayons = empty($meta['crayons']) ? array() : unserialize($meta['crayons']);
(02:28:16) cy_altern: (dément si ça marche ça !)
(02:29:19) toggg: c'est pas clair , mais ça marche
(02:29:21) cy_altern: ok, dans le privé tu récupère un array $meta[prefix_plugin] éqivalent à #CONFIG{prefix_plugin}
(02:29:46) toggg: le / est embétant , disait fil
(02:30:20) toggg: ah c'est pareil , sauf que meta est toujours serialize
(02:31:06) toggg: $meta[prefix_plugin] ou #CONFIG{prefix_plugin} , c'est serialisé
(02:31:15) cy_altern: et donc reste qu'a fournir un form html dans fonds/cfg_prefix_plugin.html avecdes  <input name="nom_variable_config"> 
(02:31:33) toggg: à peu près
(02:31:40) toggg: y des hacks
(02:31:43) toggg: :)
(02:31:46) cy_altern: et le POST de exec=cfg se charge de tout
(02:31:49) toggg: c'est rigolo
(02:31:57) toggg: oué
(02:32:07) cy_altern: trop trop top ça !
(02:32:28) toggg: [(#REM) descriptif=
(02:32:29) toggg: <h4>Exp&eacute;rimental</h4>
(02:32:29) toggg: Ici vous pouvez configurer le plugin Crayons.<br />
(02:32:29) toggg: <br /><a href="http://www.spip-contrib.net/?article1475" class="spip_out">Documentation sur contrib</a>
(02:32:29) toggg: ]
(02:32:29) toggg: [(#REM) titre=Configuration du plugin crayons]
(02:32:38) toggg: c'est des rem
(02:33:00) toggg: ça fait les titres et bloc de gauche
(02:34:00) toggg: <input type="text" name="testid" class="type_id" value="#ENV{testid}" size="10" />
(02:34:17) cy_altern: et il faut prendre modèle sur le cfg_crayons.html pour faire son cfg_prefix_plugin.html : commencer par [(#INCLURE{fond=fonds/cfg_tete}{lang}{base_url}{hash}{arg})]  et finir par [(#INCLURE{fond=fonds/cfg_pied}{lang}{hash}{arg})]
(02:34:27) toggg: ça force testid à respecter le type id
(02:34:41) toggg: ah oué
(02:34:59) cy_altern: à oué ???
(02:35:12) toggg: les pied et tete , il sont fait par cfg , normalement
(02:35:36) toggg: il faut respecter ça , t'as raison
(02:36:00) toggg: ça fai la sécurité
(02:37:17) toggg: le morceau de html est scanné analysé avant de fournir le fond
(02:37:37) toggg: comme j'avais fait chez widgets :)
(02:38:42) toggg: il faut aussi respecter l'ordre type name class dans les champs
(02:38:57) cy_altern: (02:34:27) toggg: ça force testid à respecter le type id => explique comment je fais pour imposer que <input name="toto" soit obligatoirement une date par ex ?
(02:39:22) toggg: le type existe pas encore
(02:39:35) toggg: un type c'est un regexp
(02:39:39) toggg: 1 sec
(02:39:48) cy_altern: ok : tu peux tester des mails par ex
(02:40:52) toggg: http://trac.rezo.net/trac/spip-zone/browser/_plugins_/_dev_/cfg/exec/cfg.php#L125
(02:41:01) toggg: c'est ça les types
(02:41:12) toggg: des pôv regexpes
(02:41:16) toggg: lol
(02:41:40) toggg: y en a quasi pas là
(02:41:58) toggg: mais c'est facile à rajouter
(02:42:11) cy_altern: très bien les types dans controle()
(02:42:23) cy_altern: on peut les enrichiers dans son plugin ?
(02:42:37) cy_altern: -enrichier +enrichirs
(02:42:41) toggg: pas encore , mais il faudra
(02:43:04) toggg: aussi je vais mettre un type callback
(02:43:25) toggg: histoire de pouvoir faire ce qu'on veut
(02:43:46) cy_altern: (02:29:46) toggg: le / est embétant , disait fil => pourquoi pas un truc plus "standard" des filtres du style : #CONFIG{prefix_plugin|nom_variable_config}
(02:44:00) toggg: c'est vraiement roots là 
(02:44:25) toggg: oui , je disais aussi , ben en faire un filtre
(02:44:34) cy_altern: ben quoi c'est geek-readable : tu fais un pipe :)
(02:45:13) toggg: je sais pas , y avait un autre nid à emmerde dil disait
(02:45:19) toggg: fil
(02:45:29) toggg: on verra bien
(02:45:40) toggg: c'est pas vieux
(02:45:47) toggg: tout petit
(02:46:00) toggg: mais ça marche !
(02:46:05) toggg: yo !!!!
(02:46:16) cy_altern: yo !
(02:46:36) cy_altern: ça va être très très pratique ce truc !
(02:47:20) toggg: ça fait des listes aussi , comme config_sms
(02:47:31) cy_altern: après il ya aura juste à faire un extract en xml des données sérialisées pour pouvoir se refiler/sauvegarder des fichiers de config d'un plugin
(02:47:37) toggg: qu'est l'ancêtre
(02:48:13) toggg: ah c'est dans le sql lisible hein
(02:48:24) ***cy_altern est fier d'avoir reçu le 2eme message "officiel" du plugin sms :)
(02:48:55) toggg: mais limiter à 1 cran de meta par plugin , c'est un minimum
(02:49:03) cy_altern: oué
(02:49:35) cy_altern: c'est pour ça que j'avais bricolé ce truc à base de fichier php pour saveauto : je voulais pas encombrer meta
(02:49:48) toggg: pis j'ai fait des belles fonctions aujourd'hui
(02:50:29) cy_altern: y'a qu'a voir comment certain plugin prennent leurs aises... ça sera le mieux que ton truc il soit intégré au core histoire que les devs de plugins arrêtent de faire des abus
(02:50:38) toggg: http://trac.rezo.net/trac/spip-zone/browser/_plugins_/_stable_/crayons/inc/crayons.php#L29
(02:50:48) toggg: du pur automate
(02:51:18) shiraz: Re : Problem ? mysql from 4.0 to 4.1, par Gilles Vincent (Liste anglophone) http://permalink.gmane.org/gmane.comp.web.spip.english/902
(02:51:27) toggg: ça te rends un tableau décrivant la colonne sql
(02:52:07) cy_altern: ça me fait penser que j'avais fait un truc à base de js qui automatisait les contrôles de champs lors de l'envoi d'un form...
(02:52:42) cy_altern: ça serait aussi bien de pouvoir automatiser ça à partir des types
(02:52:43) toggg: là c'est le béton coté serveur
(02:52:52) toggg: mais oui
(02:53:00) toggg: bien sûr
(02:53:33) cy_altern: histoire de pouvoir contrôler les champs facultatifs/obligatoires + valeurs par défaut
(02:53:52) toggg: on peut facilement dire , pas bon là , on soumet pas
(02:53:59) cy_altern: oué
(02:54:18) toggg: oui notnull est pas utilisé encore
(02:54:20) cy_altern: ou manque tel et tel champs, on soumet pas
(02:54:46) toggg: faut que je le change
(02:54:58) toggg: j'ai mis "obli"
(02:55:02) cy_altern: cool
(02:55:14) toggg: pas bon , "notnull"
(02:55:36) toggg: hop
(02:56:05) cy_altern: 'idnum' => array('#^\d+$#', _L('chiffres'), notnull, obli),  
(02:56:50) cy_altern:  'idnum' => array('#^\d+$#', _L('chiffres'), nonvide, obli), 
(02:59:10) toggg: heu ?
(02:59:32) cy_altern: nonvide et obli c'est pour la valid en javascript ), 
(02:59:57) toggg: #^\d+$# ça l'est
(03:00:15) toggg: bah
(03:00:29) cy_altern: ha oué : encore mieux : tu fais la première validation en javascript direct sur la regexp
(03:00:41) toggg: c'est "notnull" en tout cas
(03:01:20) toggg: les regexpes devraient être les mêmes , non ?
(03:01:30) cy_altern: alors juste 'idnum' => array('#^\d+$#', _L('chiffres'), 'obli'),
(03:02:01) cy_altern: oué, à peanuts près les regexp php elle sont valides en js
(03:02:09) toggg: en fait , je me rappelle plus
(03:02:32) toggg: c'est "notnull" en tout cas , plus "obli" , je viens de changer
(03:02:42) cy_altern: (pas sûr qu'il ya ait pas 1 ou 2 différences dans les modificateurs post expression)
(03:02:51) toggg: oué
(03:03:09) toggg: il doit y avoir des glitches
(03:03:28) toggg: en théorie , ça devrait rester simple
(03:03:52) toggg: sachant que c'est coté serveur qui compte
(03:04:00) cy_altern: oué
(03:04:20) toggg: bah
(03:04:36) toggg: c'est Card bientôt
(03:05:15) toggg: ce que j'avais mis chez http://routeit.4th.ro
(03:05:30) toggg: là c'est traduit en bash
(03:05:37) cy_altern: donc j'attends encore un peu avant de faire le fonds/cfg_saveauto.html alors :)
(03:05:53) toggg: je veux dire stocké/utilisé en bash
(03:06:06) toggg: bah non
(03:06:48) toggg: tu regardes cfg/fonds/cfg_testsimple.html
(03:07:15) cy_altern: et c'est pour csv2spip que ça va être top : du coup je vais pouvoir faire une interface de config pour définir les users autorisés à accéder au exec=csv2spip
(03:07:18) toggg: on rajoute les types/regexpes que tu veux
(03:08:22) toggg: oui , c'est le but des listes/hash que je vais rajouter
(03:08:22) cy_altern: ça pourrait se faire un type qui dit "un user de spip admin"
(03:08:55) toggg: aussi , partager put être un bout de config en cookie ?
(03:09:05) toggg: hihi
(03:09:17) cy_altern: et que la vérif elle se fasse sur la table spip_auteurs
(03:09:41) toggg: je pense que oui 
(03:10:05) toggg: c'est les callbacks comme je te disais
(03:10:44) toggg: bien sûr pas coté client , en tout cas pas pour la validation finale
(03:11:04) cy_altern: faudrait pouvoir faire un truc du style : 
(03:11:04) cy_altern: 'idnum' => array('#AUTEURS{0minirezo|toto}', _L('un administrateur du site')),
(03:11:04) toggg: hihi
(03:11:32) toggg: le modificateur "e" ?
(03:11:34) cy_altern: oué, sans vérif ôté client 
